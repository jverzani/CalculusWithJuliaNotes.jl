{
  "hash": "5d3c1612f8bced158be41d59e2dd78bb",
  "result": {
    "markdown": "# Overview of Julia commands\n\n\n\n\n\nThe [`Julia`](http://www.julialang.org) programming language is well suited as a computer accompaniment while learning the concepts of calculus. The following overview covers the language-specific aspects of the pre-calculus part of the [Calculus with Julia](calculuswithjulia.github.io) notes.\n\n\n## Installing `Julia`\n\n\n`Julia` is an *open source* project which allows anyone with a supported  computer to use it. To install locally, the [downloads](https://julialang.org/downloads/) page has several different binaries for installation. Additionally, the downloads page contains a link to a docker image.  For Microsoft Windows, the new [juilaup](https://github.com/JuliaLang/juliaup) installer may be of interest; it is available from the Windows Store. `Julia` can also be compiled from source.\n\n\n`Julia` can also be run through the web. The [https://mybinder.org/](https://mybinder.org/) service in particular allows free access, though limited in terms of allotted memory and with a relatively short timeout for inactivity.\n\n\n[Launch Binder](https://mybinder.org/v2/gh/CalculusWithJulia/CwJScratchPad.git/master)\n\n\n## Interacting with `Julia`\n\n\nAt a basic level, `Julia` provides a means to read commands or instructions, evaluate those commands, and then print or return those commands. At a user level, there are many different ways to interact with the reading and printing. For example:\n\n\n  * The REPL. The `Julia` terminal is the built-in means to interact with `Julia`. A `Julia` Terminal has a command prompt, after which commands are typed and then sent to be evaluated by the `enter` key. The terminal may look something like the following where `2+2` is evaluated:\n\n---\n\n\n\n```{verbatim}\n$ julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.7.0 (2021-11-30)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> 2 + 2\n4\n```\n\n\n---\n\n  * An IDE. For programmers, an integrated development environment is often used to manage bigger projects. `Julia` has `Juno` and `VSCode`.\n  * A notebook. The [Project Juptyer](https://jupyter.org/) provides a notebook interface for interacting with `Julia` and a more `IDE` style `jupyterlab` interface. A jupyter notebook has cells where commands are typed and immediately following is the printed output returned by `Julia`. The output of a cell depends on the state of the kernel when the cell is computed, not the order of the cells in the notebook. Cells have a number attached, showing the execution order. The `Juypter` notebook is used by `binder` and can be used locally through the `IJulia` package. This notebook has the ability to display many different types of outputs in addition to plain text, such as images, marked up math text, etc.\n  * The [Pluto](https://github.com/fonsp/Pluto.jl) package provides a *reactive* notebook interface. Reactive means when one \"cell\" is modified and executed, the new values cascade to all other dependent cells which in turn are updated. This is very useful for exploring a parameter space, say. Pluto notebooks can be exported as HTML files which make them easy to read online and â€“ by clever design â€“ embed the `.jl` file that can run through `Pluto` if it is downloaded.\n\n\nThe `Pluto` interface has some idiosyncracies that need explanation:\n\n\n  * Cells can only have one command within them. Multiple-command cells must be contained in a `begin` block or a `let` block.\n  * By default, the cells are *reactive*. This means when a variable in one cell is changed, then any references to that variable are also updated â€“ like a spreadsheet. This is fantastic for updating several computations at once. However it means variable names can not be repeated within a page. Pedagogically, it is convenient to use variable names and function names (e.g., `x` and `f`) repeatedly, but this is only possible *if* they are within a `let` block or a function body.\n  * To not repeat names, but to be able to reference a value from cell-to-cell,  some Unicode variants are used within a page. Visually these look familiar, but typing the names requires some understanding of Unicode input. The primary usages is *bold italic* (e.g., `\\bix[tab]` or `\\bif[tab]`) or *bold face* (e.g. `\\bfx[tab]` or `bff[tab]`).\n  * The notebooks snapshot the packages they depend on, which is great for reproducability, but may mean older versions are silently used.\n\n\n## Augmenting base `Julia`\n\n\nThe base `Julia` installation has many features, but leaves many others to `Julia`'s package ecosystem. These notes use packages to provide plotting, symbolic math, access to special functions, numeric routines, and more.\n\n\nWithin `Pluto`, using add-on packages is very simple, as `Pluto` downloads and installs packages when they are requested through a `using` or `import` directive.\n\n---\n\n\nFor other interfaces to `Julia` some more detail is needed.\n\n\nThe `Julia` package manager makes add-on packages very easy to install.\n\n\nJulia comes with just a few built-in packages, one being `Pkg` which manages subsequent package installation. To add more packages, we first must *load* the `Pkg` package. This is done by issuing the following command:\n\n``` {.julia .cell-code}\nusing Pkg\n```\n\n\nThe `using` command loads the specified package and makes all its *exported* values available for direct use. There is also the `import` command which allows the user to select which values should be imported from the package, if any, and otherwise gives access to the new functionality through the dot syntax.\n\n\nPackages need to be loaded just once per session.\n\n\nTo use `Pkg` to \"add\" another package, we would have a command like:\n\n``` {.julia .cell-code}\nPkg.add(\"CalculusWithJulia\")\n```\n\n\nThis command instructs `Julia` to look at its *general registry* for the `CalculusWithJulia.jl` package, download it, then install it. Once installed, a package only  needs to be brought into play with the `using` or `import` commands.\n\n\n:::{.callout-note}\n## Note\nIn a terminal setting, there is a package mode, entered by typing `]` as the leading character and exited by entering `<delete>` at a blank line. This mode allows direct access to `Pkg` with a simpler syntax. The command above would be just `add CalculusWithJulia`.)\n\n:::\n\nPackages can be updated through the command `Pkg.up()`, and removed with `Pkg.rm(pkgname)`.\n\n\nBy default packages are installed in a common area. It may be desirable to keep packages for projects isolated. For this the `Pkg.activate` command can be used. This feature allows a means to have reproducible environments even if `Julia` or the packages used are upgraded, possibly introducing incompatabilities.\n\n\nFor these notes, the following packages, among others, are used:\n\n``` {.julia .cell-code}\nPkg.add(\"CalculusWithJulia\") # for some simplifying functions and a few packages (SpecialFunctions, ForwardDiff)\nPkg.add(\"Plots\")  # for basic plotting\nPkg.add(\"SymPy\")  # for symbolic math\nPkg.add(\"Roots\")  # for solving  `f(x)=0`\nPkg.add(\"QuadGk\") # for integration\nPkg.add(\"HQuadrature\") # for higher-dimensional integration\n```\n\n\n## `Julia` commands\n\n\nIn a `Jupyter` notebook or `Pluto` notebook, commands are typed into a notebook cell:\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\n2 + 2   # use shift-enter to evaluate\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n4\n```\n:::\n:::\n\n\nCommands are executed by using `shift-enter` or a run button near the cell.\n\n\nIn `Jupyter` multiple commands per cell are allowed. In `Pluto`, a `begin` or `let` block is used to  collect multiple commmands into a single call. Commands may be separated by new lines or semicolons.\n\n\nOn a given line, anything **after** a `#` is a *comment* and is not processed.\n\n\nThe results of the last command executed will be displayed in an output area. Separating values by commas allows more than one value to be displayed.  Plots are displayed when the plot object is returned by the  last executed command.\n\n\nIn `Jupyter`, the state of the notebook is a determined by the cells executed along with their order.  The state of a `Pluto` notebook is a result of all the cells in the notebook being executed. The cell order does not impact this and can be rearranged by the user.\n\n\n## Numbers, variable types\n\n\n`Julia` has many different number types beyond the floating point type employed by most calculators. These include\n\n\n  * Floating point numbers: `0.5`\n  * Integers: `2`\n  * Rational numbers: `1//2`\n  * Complex numbers `2 + 0im`\n\n\n`Julia`'s parser finds the appropriate type for the value, when read in. The following all create the number $1$ first as an integer, then a rational, then a floating point number, again as floating point number, and finally as a complex number:\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\n1, 1//1, 1.0, 1e0, 1 + 0im\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n(1, 1//1, 1.0, 1.0, 1 + 0im)\n```\n:::\n:::\n\n\nAs much as possible, operations involving  certain types of numbers will produce output of a given type. For example, both of these divisions produce a floating point answer, even though  mathematically, they need not:\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\n2/1, 1/2\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n(2.0, 0.5)\n```\n:::\n:::\n\n\nSome powers with negative bases, like `(-3.0)^(1/3)`, are not defined. However, `Julia` provides the special-case function `cbrt` (and `sqrt`) for handling these.\n\n\nInteger operations may silently overflow, producing odd answers, at first glance:\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\n2^64\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n0\n```\n:::\n:::\n\n\n(Though the output is predictable, if overflow is taken into consideration appropriately.)\n\n\nWhen different types of numbers are mixed, `Julia` will usually promote the values to a common type before the operation:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\n(2 + 1//2) + 0.5\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n3.0\n```\n:::\n:::\n\n\n`Julia` will first add `2` and `1//2` promoting `2` to rational before doing so. Then add the result, `5//2` to `0.5` by promoting `5//2` to the floating point number `2.5` before proceeding.\n\n\n`Julia` uses a special type to store a handful of irrational constants such as `pi`. The special type allows these constants to be treated without round off, until they mix with other floating point numbers. There are some functions that require these be explicitly promoted to floating point. This can be done by calling `float`.\n\n\nThe standard mathematical operations are implemented by `+`, `-`, `*`, `/`, `^`. Parentheses are used for grouping.\n\n\n### Vectors\n\n\nA vector is an indexed collection of similarly typed values. Vectors can be constructed with square brackets (syntax for concatenation):\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\n[1, 1, 2, 3, 5, 8]\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n6-element Vector{Int64}:\n 1\n 1\n 2\n 3\n 5\n 8\n```\n:::\n:::\n\n\nValues will be promoted to a common type (or type `Any` if none exists). For example, this vector will have type `Float64` due to the `1/3` computation:\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\n[1, 1//2, 1/3]\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n3-element Vector{Float64}:\n 1.0\n 0.5\n 0.3333333333333333\n```\n:::\n:::\n\n\n(Vectors are used as a return type from some functions, as such, some familiarity is needed.)\n\n\nRegular arithmetic sequences can be defined by either:\n\n\n  * Range operations:  `a:h:b` or `a:b` which produces a generator of values starting at `a` separated by `h` (`h` is `1` in the last form) until they reach `b`.\n  * The `range` function: `range(a, b, length=n)` which produces a generator of `n` values between `a` and `b`;\n\n\nThese constructs return range objects. A range object *compactly* stores the values it references. To see all the values, they can be collected with the `collect` function, though this is rarely needed in practice.\n\n\nRandom sequences are formed by `rand`, among others:\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nrand(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n3-element Vector{Float64}:\n 0.5297355486964682\n 0.5862959855148163\n 0.9823620396723519\n```\n:::\n:::\n\n\nThe call `rand()` returns a single random number (in $[0,1)$.)\n\n\n## Variables\n\n\nValues can be assigned variable names, with `=`. There are some variants\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nu = 2\na_really_long_name = 3\na0, b0 = 1, 2    # multiple assignment\na1 = a2 = 0      # chained assignment, sets a2 and a1 to 0\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n0\n```\n:::\n:::\n\n\nThe names can be short, as above, or more verbose. Variable names can't start with a number, but can include numbers. Variables can also include [Unicode](../misc/unicode.html) or even be an emoji.\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\nÎ±, Î² = Ï€/3, Ï€/4\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n(1.0471975511965976, 0.7853981633974483)\n```\n:::\n:::\n\n\nWe can then use the variables to reference the values:\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nu + a_really_long_name + a0 - b0 + Î±\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n5.047197551196597\n```\n:::\n:::\n\n\nWithin `Pluto`, names are idiosyncratic: within the global scope, only a single usage is possible per notebook; functions and variables can be freely renamed; structures can be redefined or renamed; ...\n\n\nOutside of `Pluto`, names may be repurposed, even with values of different types (`Julia` is a dynamic language), save for (generic) function names, which have some special rules and can only be redefined as another function. Generic functions are central to `Julia`'s design. Generic functions use a method table to dispatch on, so once a name is assigned to a generic function, it can not be used as a variable name; the reverse is also true.\n\n\n## Functions\n\n\nFunctions in `Julia` are first-class objects. In these notes, we often pass them as arguments to other functions. There are many built-in functions and it is easy to define new functions.\n\n\nWe \"call\" a function by passing argument(s) to it, grouped by parentheses:\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nsqrt(10)\nsin(pi/3)\nlog(5, 100)   # log base 5 of 100\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n2.8613531161467867\n```\n:::\n:::\n\n\nWith out parentheses, the name (usually) refers to a generic name and the output lists the number of available implementations (methods).\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nlog\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nlog (generic function with 42 methods)\n```\n:::\n:::\n\n\n### Built-in functions\n\n\n`Julia` has numerous built-in [mathematical](https://docs.julialang.org/en/v1/manual/mathematical-operations/) functions, we review a few here:\n\n\n#### Powers logs and roots\n\n\nBesides `^`, there are `sqrt` and `cbrt` for powers. In addition basic functions for exponential and  logarithmic functions:\n\n\n\n```{verbatim}\nsqrt, cbrt\nexp\nlog          # base e\nlog10, log2, # also log(b, x)\n```\n\n\n#### Trigonometric functions\n\n\nThe `6` standard trig functions are implemented; their implementation for degree arguments; their inverse functions; and the hyperbolic analogs.\n\n\n\n```{verbatim}\nsin, cos, tan, csc, sec, cot\nasin, acos, atan, acsc, asec, acot\nsinh, cosh, tanh, csch, sech, coth\nasinh, acosh, atanh, acsch, asech, acoth\n```\n\n\nIf degrees are preferred, the following are defined to work with arguments in degrees:\n\n\n\n```{verbatim}\nsind, cosd, tand, cscd, secd, cotd\n```\n\n\n#### Useful functions\n\n\nOther useful and familiar functions are defined:\n\n\n  * `abs`: absolute value\n  * `sign`: is $\\lvert x \\rvert/x$ except at $x=0$, where it is $0$.\n  * `floor`, `ceil`: greatest integer less or least integer greater\n  * `max(a,b)`, `min(a,b)`: larger (or smaller) of `a` or `b`\n  * `maximum(xs)`, `minimum(xs)`: largest or smallest of the collection referred to by `xs`\n\n\n---\n\nIn a Pluto session, the \"Live docs\" area shows inline documentation for the current object.\n\n\nFor other uses of `Julia`, the built-in documentation for an object is accessible through a leading `?`, say, `?sign`. There is also the `@doc` macro, for example:\n\n``` {.julia .cell-code}\n@doc sign\n```\n\n\n---\n\n\n### User-defined functions\n\n\nSimple mathematical functions can be defined using standard mathematical notation:\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\nf(x) = -16x^2 + 100x + 2\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\nf (generic function with 1 method)\n```\n:::\n:::\n\n\nThe argument `x` is passed into the body of function.\n\n\nOther values are found from  the environment where defined:\n\n::: {.cell hold='true' execution_count=21}\n``` {.julia .cell-code}\na = 1\nf(x) = 2*a + x\nf(3)   # 2 * 1 + 3\na = 4\nf(3)  # now 2 * 4 + 3\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n11\n```\n:::\n:::\n\n\nUser-defined functions can have $0$, $1$ or more arguments:\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\narea(w, h) = w*h\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\narea (generic function with 1 method)\n```\n:::\n:::\n\n\nJulia makes different *methods* for *generic* function names, so function definitions whose argument specification is different are for different uses, even if the name is the same. This is *polymorphism*. The practical use is that it means users need only remember a much smaller set of function names, as attempts are made to give common expectations to the same name. (That is, `+` should be used only for \"add\" ing objects, however defined.)\n\n\nFunctions can be defined with *keyword* arguments that may have defaults specified:\n\n::: {.cell hold='true' execution_count=23}\n``` {.julia .cell-code}\nf(x; m=1, b=0) = m*x + b     # note \";\"\nf(1)                         # uses m=1, b=0   -> 1 * 1 + 0\nf(1, m=10)                   # uses m=10, b=0  -> 10 * 1 + 0\nf(1, m=10, b=5)              # uses m=10, b=5  -> 10 * 1 + 5\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n15\n```\n:::\n:::\n\n\nLonger functions can be defined using the `function` keyword, the last command executed is returned:\n\n::: {.cell execution_count=24}\n``` {.julia .cell-code}\nfunction ð’‡(x)\n  y = x^2\n  z = y - 3\n  z\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\nð’‡ (generic function with 1 method)\n```\n:::\n:::\n\n\nFunctions without names, *anonymous functions*, are made with the `->` syntax as in:\n\n::: {.cell execution_count=25}\n``` {.julia .cell-code}\nx -> cos(x)^2 - cos(2x)\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n#13 (generic function with 1 method)\n```\n:::\n:::\n\n\nThese are useful when passing a function to another function or when writing a function that *returns* a function.\n\n\n## Conditional statements\n\n\n`Julia` provides the traditional `if-else-end` statements, but more conveniently has a `ternary` operator for the simplest case:\n\n::: {.cell execution_count=26}\n``` {.julia .cell-code}\nour_abs(x) = (x < 0) ? -x : x\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\nour_abs (generic function with 1 method)\n```\n:::\n:::\n\n\n## Looping\n\n\nIterating over a collection can be done with the traditional `for` loop. However, there are list comprehensions to mimic the definition of a set:\n\n::: {.cell execution_count=27}\n``` {.julia .cell-code}\n[x^2 for x in 1:10]\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n10-element Vector{Int64}:\n   1\n   4\n   9\n  16\n  25\n  36\n  49\n  64\n  81\n 100\n```\n:::\n:::\n\n\nComprehensions can be filtered through the `if` keyword\n\n::: {.cell execution_count=28}\n``` {.julia .cell-code}\n[x^2 for x in 1:10 if iseven(x)]\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n5-element Vector{Int64}:\n   4\n  16\n  36\n  64\n 100\n```\n:::\n:::\n\n\nThis is more efficient than creating the collection then filtering, as is done with:\n\n::: {.cell execution_count=29}\n``` {.julia .cell-code}\nfilter(iseven, [x^2 for x in 1:10])\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n5-element Vector{Int64}:\n   4\n  16\n  36\n  64\n 100\n```\n:::\n:::\n\n\n## Broadcasting, mapping\n\n\nA function can be applied to each element of a vector through mapping or broadcasting. The latter is implemented in a succinct notation. Calling a function with a \".\" before its opening \"(` will apply the function to each individual value in the argument:\n\n::: {.cell execution_count=30}\n``` {.julia .cell-code}\nxs = [1,2,3,4,5]\nsin.(xs)     # gives back [sin(1), sin(2), sin(3), sin(4), sin(5)]\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n5-element Vector{Float64}:\n  0.8414709848078965\n  0.9092974268256817\n  0.1411200080598672\n -0.7568024953079282\n -0.9589242746631385\n```\n:::\n:::\n\n\nFor \"infix\" operators, the dot precedes the operator, as in this example instructing pointwise multiplication of each element in `xs`:\n\n\n\n```{juila}\nxs .* xs\n```\n\n\nAlternatively, the more traditional `map` can be used:\n\n::: {.cell execution_count=31}\n``` {.julia .cell-code}\nmap(sin, xs)\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n5-element Vector{Float64}:\n  0.8414709848078965\n  0.9092974268256817\n  0.1411200080598672\n -0.7568024953079282\n -0.9589242746631385\n```\n:::\n:::\n\n\n## Plotting\n\n\nPlotting is *not* built-in to `Julia`, rather added through add-on packages.  `Julia`'s `Plots` package is an interface to several plotting packages. We mention `plotly` (built-in) for web based graphics, `pyplot`, and `gr` (also built into `Plots`) for other graphics.\n\n\nWe must load `Plots` before we can plot (and it must be installed before we can load it):\n\n``` {.julia .cell-code}\nusing Plots\n```\n\n\nWith `Plots` loaded, we can plot a function by passing the function object by name to `plot`, specifying the range of `x` values to show, as follows:\n\n::: {.cell execution_count=33}\n``` {.julia .cell-code}\nplot(sin, 0, 2pi) # plot a function - by name - over an interval [a,b]\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n![](julia_overview_files/figure-html/cell-34-output-1.svg){}\n:::\n:::\n\n\n!!1 note \tThis is in the form of **the** basic pattern employed: `verb(function_object, arguments...)`. The verb in this example is `plot`, the object `sin`, the arguments `0, 2pi` to specify `[a,b]` domain to plot over.\n\n\nPlotting more than one function over `[a,b]` is achieved through the `plot!` function, which modifies the existing plot (`plot` creates a new one) by adding a new layer:\n\n::: {.cell execution_count=34}\n``` {.julia .cell-code}\nplot(sin, 0, 2pi)\nplot!(cos, 0, 2pi)\nplot!(zero, 0, 2pi) # add the line y=0\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n![](julia_overview_files/figure-html/cell-35-output-1.svg){}\n:::\n:::\n\n\nIndividual points are added with `scatter` or `scatter!`:\n\n::: {.cell execution_count=35}\n``` {.julia .cell-code}\nplot(sin, 0, 2pi, legend=false)\nplot!(cos, 0, 2pi)\nscatter!([pi/4, pi+pi/4], [sin(pi/4), sin(pi + pi/4)])\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n![](julia_overview_files/figure-html/cell-36-output-1.svg){}\n:::\n:::\n\n\n(The extra argument `legend=false` suppresses the automatic legend drawing. There are many other useful arguments to adjust a graphic. For example, passing `markersize=10` to the `scatter!` command would draw the points larger than the default.)\n\n\nPlotting an *anonymous* function is a bit more immediate than the two-step approach of defining a named function then calling `plot` with this as an argument:\n\n::: {.cell execution_count=36}\n``` {.julia .cell-code}\nplot( x -> exp(-x/pi) * sin(x), 0, 2pi)\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n![](julia_overview_files/figure-html/cell-37-output-1.svg){}\n:::\n:::\n\n\nThe `scatter!` function used above takes two vectors of values to describe the points to plot, one for the $x$ values and one for the matching $y$ values. The `plot` function can also produce plots with this interface. For example, here we use a comprehension to produce `y` values from the specified `x` values:\n\n::: {.cell hold='true' execution_count=37}\n``` {.julia .cell-code}\nxs = range(0, 2pi, length=251)\nys = [sin(2x) + sin(3x) + sin(4x) for x in xs]\nplot(xs, ys)\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n![](julia_overview_files/figure-html/cell-38-output-1.svg){}\n:::\n:::\n\n\n## Equations\n\n\nNotation for `Julia` and math is *similar* for functions - but not for equations. In math, an equation  might look like:\n\n\n\n$$\nx^2 + y^2 = 3\n$$\n\n\nIn `Julia` the equals sign is **only** for *assignment* and *mutation*. The *left-hand* side of an equals sign in `Julia` is reserved for a) variable assignment; b) function definition (via `f(x) = ...`); c) indexed mutation of a vector or array; d) mutation of fields in a structure. (Vectors are indexed by a number allowing retrieval and mutation of the stored value in the container. The notation mentioned here would be `xs[2] = 3` to mutate the 2nd element of `xs` to the value `3`.\n\n\n## Symbolic math\n\n\nSymbolic math is available through an add-on package `SymPy` (among others).  Once loaded, symbolic variables are created with the macro `@syms`:\n\n``` {.julia .cell-code}\nusing SymPy\n```\n\n\n::: {.cell execution_count=39}\n``` {.julia .cell-code}\n@syms x a b c\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\n(x, a, b, c)\n```\n:::\n:::\n\n\n(A macro rewrites values into other commands before they are interpreted. Macros are prefixed with the `@` sign. In this use, the \"macro\" `@syms` translates `x a b c` into a command involving `SymPy`s `symbols` function.)\n\n\nSymbolic expressions - unlike numeric expressions - are not immediately evaluated, though they may be  simplified:\n\n::: {.cell execution_count=40}\n``` {.julia .cell-code}\np = a*x^2 + b*x + c\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```{=html}\n<span class=\"math-left-align\" style=\"padding-left: 4px; width:0; float:left;\"> \n\\[\na x^{2} + b x + c\n\\]\n</span>\n```\n:::\n:::\n\n\nTo substitute a value, we can use `Julia`'s `pair` notation (`variable=>value`):\n\n::: {.cell execution_count=41}\n``` {.julia .cell-code}\np(x=>2), p(x=>2, a=>3, b=>4, c=>1)\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n(4*a + 2*b + c, 21)\n```\n:::\n:::\n\n\nThis is convenient notation for calling the `subs` function for `SymPy`.\n\n\nSymPy expressions of a single free variable can be plotted directly:\n\n::: {.cell execution_count=42}\n``` {.julia .cell-code}\nplot(64 - (1/2)*32 * x^2, 0, 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n![](julia_overview_files/figure-html/cell-43-output-1.svg){}\n:::\n:::\n\n\n  * SymPy has functions for manipulating expressions: `simplify`, `expand`, `together`, `factor`, `cancel`, `apart`,  $...$\n  * SymPy has functions for basic math: `factor`, `roots`, `solve`, `solveset`, $\\dots$\n  * SymPy has functions for calculus: `limit`, `diff`, `integrate`, $\\dots$\n\n",
    "supporting": [
      "julia_overview_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}